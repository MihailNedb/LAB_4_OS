# LAB_4_OS
# Лабораторная работа №4: Межпроцессное взаимодействие через общий файл

## Описание проекта

Программа реализует механизм передачи сообщений между процессами через общий бинарный файл, организованный как кольцевая очередь (FIFO). Система состоит из одного процесса **Receiver** и нескольких процессов **Sender**.

## Архитектура системы

### Компоненты программы:

1. **Receiver** - главный процесс-получатель
2. **Sender** - процессы-отправители (может быть несколько)
3. **Общий бинарный файл** - разделяемая память для сообщений
4. **Синхронизация** - мьютексы и события для координации процессов

### Структура данных

```
Заголовок очереди (16 байт):
- capacity: int - максимальное количество сообщений
- head: int    - позиция для чтения
- tail: int    - позиция для записи
- count: int   - текущее количество сообщений

Данные (capacity × 20 байт):
- Сообщения фиксированной длины 20 символов
```

## Требования к реализации

### Процесс Receiver должен:

1. **Инициализация:**
   - Ввести имя бинарного файла
   - Ввести количество записей в файле (емкость очереди)
   - Создать и инициализировать бинарный файл

2. **Запуск процессов:**
   - Ввести количество процессов Sender
   - Запустить указанное количество процессов Sender
   - Передать каждому Sender имя файла через командную строку

3. **Ожидание готовности:**
   - Дождаться сигнала готовности от всех процессов Sender

4. **Основной цикл:**
   - Обрабатывать команды с консоли:
     - `read` - прочитать сообщение из файла
     - `exit` - завершить работу
   - При чтении из пустого файла - переходить в состояние ожидания

### Процесс Sender должен:

1. **Инициализация:**
   - Получить имя файла из командной строки
   - Открыть существующий бинарный файл

2. **Сигнализация готовности:**
   - Отправить сигнал готовности процессу Receiver

3. **Основной цикл:**
   - Обрабатывать команды с консоли:
     - `send` - отправить сообщение
     - `exit` - завершить работу
   - При записи в заполненный файл - переходить в состояние ожидания

## Установка и сборка

### Требования:
- Windows ОС
- CMake 3.15+
- Компилятор C++17 (Visual Studio 2022 рекомендуется)


## Использование

### Запуск Receiver:

```bash
OS_LAB_4.exe
```

Программа запросит:
1. Имя бинарного файла (например: `messages.bin`)
2. Количество записей (емкость очереди)
3. Количество процессов Sender

### Запуск Sender вручную:

```bash
OS_LAB_4.exe sender <имя_файла> <ID_процесса>
```

Пример:
```bash
OS_LAB_4.exe sender messages.bin 0
OS_LAB_4.exe sender messages.bin 1
```

## Команды взаимодействия

### В процессе Receiver:
```
read    - прочитать следующее сообщение из очереди
exit    - завершить работу и все процессы Sender
```

### В процессе Sender:
```
send    - отправить сообщение (запросит текст)
exit    - завершить работу данного процесса
```

## Особенности реализации

### Синхронизация:
- **Мьютекс** (`QueueMutex`) - для эксклюзивного доступа к файлу
- **События:**
  - `QueueNotEmpty` - сигнализирует, когда в очереди есть сообщения
  - `QueueNotFull` - сигнализирует, когда в очереди есть свободное место
  - `SenderReady_N` - события готовности каждого Sender процесса

### Алгоритм работы очереди:

1. **Запись сообщения (Sender):**
   - Ожидание события `QueueNotFull`
   - Захват мьютекса
   - Запись сообщения в позицию `tail`
   - Увеличение `tail = (tail + 1) % capacity`
   - Увеличение `count`
   - Освобождение мьютекса
   - Установка события `QueueNotEmpty`

2. **Чтение сообщения (Receiver):**
   - Ожидание события `QueueNotEmpty`
   - Захват мьютекса
   - Чтение сообщения из позиции `head`
   - Увеличение `head = (head + 1) % capacity`
   - Уменьшение `count`
   - Освобождение мьютекса
   - Установка события `QueueNotFull`

## Структура проекта

```
OS_LAB_4/
├── CMakeLists.txt           # Конфигурация сборки
├── CMakePresets.json        # Предустановки CMake
├── OS_LAB_4.cpp            # Точка входа
├── receiver.h              # Заголовочный файл Receiver
├── receiver.cpp            # Реализация Receiver
├── sender.h                # Заголовочный файл Sender
├── sender.cpp              # Реализация Sender
├── queue_file.h            # Работа с файлом очереди
├── queue_file.cpp          # Реализация файловых операций
├── sync_utils.h            # Синхронизация и утилиты
├── sync_utils.cpp          # Реализация синхронизации
├── tests.cpp               # Модульные тесты
└── README.md               # Документация
```

## Тестирование

### Модульные тесты включают:

1. **Структуры данных:**
   - Проверка размера и выравнивания структур
   - Константы программы

2. **Файловые операции:**
   - Инициализация файла
   - Чтение/запись сообщений
   - Обновление заголовка

3. **Синхронизация:**
   - Создание и открытие объектов синхронизации
   - Работа с событиями и мьютексами

4. **Логика очереди:**
   - Кольцевой буфер
   - Условия полноты/пустоты
   - Инварианты очереди

5. **Интеграционные тесты:**
   - Многократные циклы записи/чтения
   - Быстрые операции
   - Граничные случаи

### Запуск тестов:

```bash
# Сборка с тестами
cmake --preset tests-debug
cmake --build --preset tests-build

# Запуск всех тестов
ctest --preset test-default

# Или напрямую
./build/tests-debug/OS_LAB_4_tests.exe
```

## Обработка ошибок

Программа обрабатывает следующие ситуации:

1. **Файловые ошибки:**
   - Не удалось создать/открыть файл
   - Ошибки чтения/записи

2. **Синхронизация:**
   - Таймауты ожидания объектов
   - Ошибки создания объектов синхронизации

3. **Очередь:**
   - Попытка чтения из пустой очереди
   - Попытка записи в полную очередь

4. **Процессы:**
   - Ошибки запуска процессов
   - Преждевременное завершение процессов

## Ограничения

1. **Длина сообщения:** фиксированная 20 символов (более длинные обрезаются)
2. **Количество Sender процессов:** ограничено только системными ресурсами
3. **Размер файла:** зависит от емкости очереди (capacity × 20 + 16 байт)
4. **ОС:** разработано для Windows (использует WinAPI)



## Заключение

Программа демонстрирует принципы межпроцессного взаимодействия через общую память (файл), синхронизацию процессов и реализацию кольцевой очереди. Решение является масштабируемым и отказоустойчивым благодаря использованию механизмов синхронизации Windows API.
